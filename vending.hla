/*
	HLA Vending Machine (Programming Project 1)

	written by			Casey Hall
	created on			7 October 2015

	This program is a simple vending machine simulator, allowing the user to buy
	various items operated on a currency of 'credits'

 */

program VendingMachine;

// ------------------------------ List Structure ------------------------------
/*
	The list is stored in an 8 byte block in memory.
	struct (8 bytes) {
		DWORD length (4 bytes) [0]
		DWORD first element pointer (4 bytes) [4]
	}
*/

// --------------------------- List Item Structure ----------------------------
/*
	Each element is stored in a 16 byte block in memory
	struct (16 bytes) {
		DWORD string pointer (4 bytes) [0]
		DWORD price (4 bytes) [4]
		DWORD quantity (4 bytes) [8]
		DWORD next element pointer (4 bytes) [12]
	}
*/

// --------------------------------- Includes ---------------------------------

#include ("stdlib.hhf");
#include ("console.hhf");

// ----------------------- Static Variable Declarations -----------------------

static
	//The vending machine product list
	productList: dword;
	//The receipt entries list
	receiptList: dword;
	userWallet: uns32;

// --------------------- Procedure Forwards Declarations ----------------------

//List declarations

	//Allocates the list on the heap
	procedure list_createList; @returns("eax"); @forward;
	//Deletes the list, cleaning up all list elements
	procedure list_deleteList(listPointer:dword); @forward;
	//Used by list_deleteList only
	procedure list_recursiveDeleteItems(itemPointer:dword); @forward;
	//Gets the number of elements in the list
	procedure list_getLength(listPointer:dword); @returns("eax"); @forward;
	//Gets the pointer of the first item from the listPointer
	procedure list_getFirstItem(listPointer:dword); @returns("eax"); @forward;
	//Gets the very last item in the list (iterates the list)
	procedure list_getLastItem(listPointer:dword); @returns("eax"); @forward;
	//Gets the last existing pointer that needs to be written to if a new list
	//item is to be created
	procedure list_getLastPointer(listPointer:dword); @returns("eax"); @forward;
	//Creates a new item entry, allocating it on the heap, generating all the
	//required pieces of info, and appends it to the list. It then returns the
	//pointer to the newly created item
	procedure list_createItem(listPointer:dword; itemName:string; itemPrice:uns32; itemQuantity:uns32); @returns("eax"); @forward;

	//Look up the item in the list by index
	procedure list_getItem(listPointer:dword; itemIndex:uns32); @returns("eax"); @forward;

	//List entry accessors
	procedure list_getItemName(itemPointer:dword); @returns("eax"); @forward;
	procedure list_getItemPrice(itemPointer:dword); @returns("eax"); @forward;
	procedure list_getItemQuantity(itemPointer:dword); @returns("eax"); @forward;

	//List entry modifier. Register friendly.
	procedure list_decrementItemQuantity(itemPointer:dword); @forward;
	procedure list_incrementItemQuantity(itemPointer:dword); @forward;

//Input declarations
	procedure input_getNumber(promptText:string); @returns("eax"); @forward;

	procedure input_getNumberInRange(promptText:string; min:uns32; max:uns32); @returns("eax"); @forward;

//Rendering declarations
	procedure renderClear; @forward;

	procedure renderLine; @forward;

	procedure renderItem(itemNumber:uns32; itemPointer:dword); @forward;

	procedure renderItems(listPointer:dword); @forward;

//Money declarations

	procedure currency_addCredit(currencyAmount:uns32); @forward;
	procedure currency_subtractCredit(currencyAmount:uns32); @forward;

// -------------------------- Procedure Definitions ---------------------------

//List definitions

	procedure list_createList;
		begin list_createList;
			//Create a qword on the heap
			//It's already zeroed out
			mem.zalloc(8);
		end list_createList;

	procedure list_deleteList(listPointer:dword);
		begin list_deleteList;
			push(eax);

			mov(listPointer, eax);
			if (eax != 0) then
				//Only try to delete items if the list isn't null

				//Offset the list pointer by 4 getting the first element pointer
				mov([eax + 4], eax);
				list_recursiveDeleteItems(eax);
			endif;
			
			mem.free(listPointer);

			pop(eax);
		end list_deleteList;

	procedure list_recursiveDeleteItems(itemPointer:dword);
		begin list_recursiveDeleteItems;
			push(eax);
			push(ebx);

			//Move the item pointer into eax and ebx
			mov(itemPointer, eax);
			mov(eax, ebx);
			//Offset 12 of the structure, next pointer's pointer stored in ebx
			add(12, ebx);
			//Dereference it because we're pointing to a pointer
			mov([ebx], ebx);
			//ebx then is the address to the next element
			//If the given item isn't null, call delete on the item it points
			//to, then delete it.
			if (ebx != 0) then
				list_recursiveDeleteItems(ebx);
			endif;

			//Delete this object
			mem.free(eax);

			pop(ebx);
			pop(eax);
		end list_recursiveDeleteItems;

	procedure list_getLength(listPointer:dword);
		begin list_getLength;
			//Grab a dword from the pointer location offset 0
			mov(listPointer, eax);
			mov([eax], eax);
		end list_getLength;

	procedure list_getFirstItem(listPointer:dword);
		begin list_getFirstItem;
			//Grab a dword from the pointer location offset 4
			mov(listPointer, eax);
			mov([eax + 4], eax);
		end list_getFirstItem;

	procedure list_getLastItem(listPointer:dword);
		//Destroys eax
		begin list_getLastItem;
			//Save old ebx
			push(ebx);

			//Move the first item into both eax and ebx
			list_getFirstItem(listPointer);
			//Ebx stores the newly read pointer, eax stores the current one
			mov(eax, ebx);

			//Loop until we get the last item
			forever
				//If the current pointer we just read is null, we break
				//If there are no entries, it should be null, so we break
				//EAX is already set to null, so we just return if there are no
				//entries and the calling function handles it
				breakif(ebx == 0);

				//It's not null, move the just read pointer to eax as this is the
				//valid pointer of the most recent struct
				mov(ebx, eax);

				//Read offset 12 in memory of the known valid pointer into ebx,
				//then going to the next loop iteration until we hit null and stop
				mov([eax + 12], ebx);
			endfor;

			//Restore old ebx from the stack
			pop(ebx);

			//EAX now contains the last entry in the linked list
		end list_getLastItem;

	procedure list_getLastPointer(listPointer:dword);
		begin list_getLastPointer;
			//Put the last item in eax
			list_getLastItem(listPointer);
			//Add 12 to get that object's 'next' pointer address if the object
			//exists. If it's 0 then just return the address to the list's first
			//object pointer because it's the first object to be created
			if (eax != 0) then
				add(12, eax);
			else
				//Put the list pointer back into eax
				mov(listPointer, eax);
				//And return offset 4 of that, being the pointer to the first
				//object
				add(4, eax);
			endif;
				
			//And that's all there is.
		end list_getLastPointer;

	procedure list_createItem(listPointer:dword; itemName:string; itemPrice:uns32; itemQuantity:uns32);
		//Destroys eax
		begin list_createItem;
			//Save old ebx, ecx
			push(ebx);
			push(ecx);

			//Put the next pointer to be written in eax. If there are no new
			//objects, it returns the address of the base object's first item
			//pointer
			list_getLastPointer(listPointer);

			//move that to ecx
			mov(eax, ecx);

			//Allocate 16 bytes for the list item
			mem.zalloc(16);

			//Write the address (in eax) of the new list item into the location
			//specified by ecx (the next pointer to be written)
			mov(eax, [ecx]);

			//Write the new object out

			//Offset 0-3
			mov((type dword itemName), [eax]);

			//Offset 4-7
			mov(itemPrice, [eax + 4]);

			//Offset 8-11
			mov(itemQuantity, [eax + 8]);

			//Increment the list counter
			//also overwriting/recycling ebx and ecx
			mov(listPointer, ebx);
			mov([ebx], ecx);
			inc(ecx);
			mov(ecx, [ebx]);

			pop(ecx);
			pop(ebx);

			//And we return, leaving the pointer to the new object in eax
		end list_createItem;

	procedure list_getItem(listPointer:dword; itemIndex:uns32);
		//Destroys eax
		begin list_getItem;
			//Move the first item pointer into eax
			list_getFirstItem(listPointer);

			//Save ecx, ebx
			push(ecx);
			push(ebx);
			
			for (mov(0, ecx); ecx < itemIndex; inc(ecx)) do
				//We already have the 0 index pointer
				if (itemIndex == 0) then
					break;
				endif;

				//Read the actual pointer from memory into eax
				add(12, eax);
				//Read the value at the new pointer location
				mov([eax], eax);
			endfor;

			pop(ebx);
			pop(ecx);

		end list_getItem;

	procedure list_getItemName(itemPointer:dword);
		//Destroys eax
		begin list_getItemName;
			mov(itemPointer, eax);
			mov([eax], eax);
		end list_getItemName;

	procedure list_getItemPrice(itemPointer:dword);
		//Destroys eax
		begin list_getItemPrice;
			mov(itemPointer, eax);
			mov([eax + 4], eax);
		end list_getItemPrice;

	procedure list_getItemQuantity(itemPointer:dword);
		//Destroys eax
		begin list_getItemQuantity;
			mov(itemPointer, eax);
			mov([eax + 8], eax);
		end list_getItemQuantity;

	procedure list_decrementItemQuantity(itemPointer:dword);
		begin list_decrementItemQuantity;
			push(eax);
			push(ebx);

			//Move the item pointer to eax
			mov(itemPointer, eax);
			//Move the value at offset 8 to ebx
			mov([eax + 8], ebx);
			//Decrement ebx
			dec(ebx);
			//Move ebx back into eax offset 8
			mov(ebx, [eax + 8]);

			pop(ebx);
			pop(eax);
		end list_decrementItemQuantity;

	procedure list_incrementItemQuantity(itemPointer:dword);
		begin list_incrementItemQuantity;
			push(eax);
			push(ebx);

			//Move the item pointer to eax
			mov(itemPointer, eax);
			//Move the value at offset 8 to ebx
			mov([eax + 8], ebx);
			//Increment ebx
			inc(ebx);
			//Move ebx back into eax offset 8
			mov(ebx, [eax + 8]);

			pop(ebx);
			pop(eax);
		end list_incrementItemQuantity;

//Input definitions
	procedure input_getNumber(promptText:string);
		//Destroys eax
		begin input_getNumber;
			forever
				try
					//Flush input and get number
					stdin.flushInput();

					//Output the prompt
					
					mov(promptText, eax);
					if (eax != 0) then
						stdout.put(promptText);
					endif;

					stdin.getu32();
					
					unprotected
						break;
				anyexception
					stdout.put("You have entered an invalid number. Please try again.", nl);
				endtry;
			endfor;
		end input_getNumber;

	procedure input_getNumberInRange(promptText:string; min:uns32; max:uns32);
		begin input_getNumberInRange;
			forever
				input_getNumber(promptText);

				if (eax > max || eax < min) then
					stdout.put("You have entered a number out of range. (", min, "-", max, ")", nl);
				else
					break;
				endif;

			endfor;
		end input_getNumberInRange;

//Rendering definitions
	procedure renderClear;
		begin renderClear;
			console.home();
		end renderClear;

	procedure renderLine;
		begin renderLine;
			stdout.put("------------------------------------------------", nl);
		end renderLine;

	procedure renderItem(itemNumber:uns32; itemPointer:dword);
		begin renderItem;
			push(eax);

			mov(itemNumber, eax);
			if (eax > 0) then
				stdout.put((type uns32 eax), ". ");
			endif;

			list_getItemName(itemPointer);
			stdout.put("Name: ", (type string eax), ", ");

			list_getItemPrice(itemPointer);
			stdout.put("Price: ", (type uns32 eax), ", ");

			list_getItemQuantity(itemPointer);
			stdout.put("Quantity: ", (type uns32 eax), " ", nl);

			pop(eax);
		end renderItem;

	procedure renderItems(listPointer:dword);
		begin renderItems;
			push(eax);
			push(ebx);
			push(ecx);
			push(edx);

			//Put the length in edx
			list_getLength(listPointer);
			mov(eax, edx);

			//Loop through all items
			for (mov(0, ecx); ecx < edx; inc(ecx)) do
				//Get the list item at index of ecx
				list_getItem(listPointer, ecx);
				renderItem(0, eax);
			endfor;

			pop(edx);
			pop(ecx);
			pop(ebx);
			pop(eax);
		end renderItems;

//Money definitions

	procedure currency_addCredit(currencyAmount:uns32);
		begin currency_addCredit;
		end currency_addCredit;

	procedure currency_subtractCredit(currencyAmount:uns32);
		begin currency_subtractCredit;
		end currency_subtractCredit;

// --------------------------- Program Entry Point ----------------------------

begin VendingMachine;
	list_createList();
	mov(eax, productList);
	list_createItem(productList, "Coke", 199, 100);
	list_createItem(productList, "Diet Coke", 189, 100);
	list_createItem(productList, "Sprite", 199, 100);
	list_createItem(productList, "Dr. Pepper", 199, 100);

	renderItems(productList);

	list_deleteList(productList);

end VendingMachine;