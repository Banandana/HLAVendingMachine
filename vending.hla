/*
	HLA Vending Machine (Programming Project 1)

	written by			Casey Hall
	created on			7 October 2015

	This program is a simple vending machine simulator, allowing the user to buy
	various items operated on a currency of 'credits'

 */

program VendingMachine;

// --------------------------- List Item Structure ----------------------------
/*
	Each element is stored in a 16 byte block in memory
	struct (16 bytes) {
		DWORD string pointer (4 bytes) [0]
		DWORD price (4 bytes) [4]
		DWORD quantity (4 bytes) [8]
		DWORD next element pointer (4 bytes) [12]
	}
*/

// --------------------------------- Includes ---------------------------------

#include ("stdlib.hhf");
#include ("console.hhf");

// ----------------------- Static Variable Declarations -----------------------

static
	//The first vending machine item pointer in the linked list
	firstItem: dword;
	itemCount: uns32;
	userWallet: uns32;

// --------------------- Procedure Forwards Declarations ----------------------

//List declarations

	//Creates a new item entry, allocating it on the heap, generating all the
	//required pieces of info, and appends it to the list. It then returns the
	//pointer to the newly created item
	procedure list_createItem(itemName:string; itemPrice:uns32; itemQuantity:uns32); @returns("eax"); @forward;

	//Look up the item in the list by index
	procedure list_getItem(itemIndex:uns32); @returns("eax"); @forward;
 
	procedure list_removeItem(itemIndex:uns32); @forward;

	//List entry accessors
	procedure list_getItemName(itemPointer:dword); @returns("eax"); @forward;
	procedure list_getItemPrice(itemPointer:dword); @returns("eax"); @forward;
	procedure list_getItemQuantity(itemPointer:dword); @returns("eax"); @forward;

	//List entry modifier. Register friendly.
	procedure list_decrementItemQuantity(itemPointer:dword); @forward;

	//Gets the very last item in the list
	procedure list_getLastItem; @returns("eax"); @forward;

//Input declarations
	procedure input_getNumber(promptText:string); @returns("eax"); @forward;

	procedure input_getNumberInRange(promptText:string; min:uns32; max:uns32); @returns("eax"); @forward;

//Rendering declarations
	procedure renderClear; @forward;

	procedure renderLine; @forward;

	procedure renderItem(itemNumber:uns32; itemPointer:dword); @forward;

	procedure renderItems; @forward;

//Money declarations

	procedure currency_addCredit(currencyAmount:uns32); @forward;
	procedure currency_subtractCredit(currencyAmount:uns32); @forward;

// -------------------------- Procedure Definitions ---------------------------

//List definitions

	procedure list_createItem(itemName:string; itemPrice:uns32; itemQuantity:uns32);
		//Destroys eax
		begin list_createItem;
			//Save old ebx
			push(ebx);

			//Allocate 16 bytes
			mem.zalloc(16);
			//EAX now contains the pointer to this block
			mov(eax, ebx);
			//Now EBX has it

			//Get the pointer of the last entry to EAX
			call list_getLastItem;

			//Copy the string to the destination specified in ebx
			//Offset 0-3
			mov((type dword itemName), [ebx]);

			//Offset 4-7
			mov(itemPrice, [ebx + 4]);

			//Offset 8-11
			mov(itemQuantity, [ebx + 8]);

			//Make sure eax isn't null, never write to invalid memory
			if (eax != 0) then
					//Offset 12-15 is a pointer to the next item entry
					//Note this is the offset of the list_getLastItem block and not
					//the newly created one
					mov(ebx, [eax + 12]);
				else
					//LastItemEntry is null, meaning that this is the first item in
					//the list. Move the new structure's pointer to firstItem
					mov(ebx, firstItem);
			endif;

			//Increment itemCount, preserving ecx
			push(ecx);
			mov(itemCount, ecx);
			inc(ecx);
			mov(ecx, itemCount);
			pop(ecx);
			
			//At this point, ebx contains the pointer to the created object
			//Move into eax and restore old ebx
			mov(ebx, eax);
			pop(ebx);

			//And we return, leaving the pointer to the new object in eax
		end list_createItem;

	procedure list_getItem(itemIndex:uns32);
		//Destroys eax
		begin list_getItem;
			//Move the first item pointer into eax
			mov(firstItem, eax);

			//Save ecx, ebx
			push(ecx);
			push(ebx);
			
			for (mov(0, ecx); ecx < itemIndex; inc(ecx)) do
				//We already have the 0 index pointer
				if (itemIndex == 0) then
					break;
				endif;

				//Read the actual pointer from memory into eax
				add(12, eax);
				//Read the value at the new pointer location
				mov([eax], eax);
			endfor;

			pop(ebx);
			pop(ecx);

		end list_getItem;

	procedure list_removeItem(itemIndex:uns32);
		begin list_removeItem;
			push(eax);
			push(ebx);
			push(ecx);
			push(edx);
			push(ebp);
			
			mov(itemIndex, eax);
			//Because the list is zero indexed, decrease the itemcount to get the
			//index of the last item in the list
			mov(itemCount, ebx);
			dec(ebx);

			if (eax > 0 && eax < ebx) then
				//Normal removal

				//get the index of the item before
				dec(eax);

				//eax is now the pointer to the item before
				list_getItem(eax);

				//Offset the pointer of the item before by 12
				//eax is then the address of the pointer of the target object
				add(12, eax);

				//Move that to ebx
				//move a copy of the address of the pointer to be updated on the previous object
				//to ebx
				mov(eax, ebx);

				//eax is dereferenced and is now a pointer to the item to be removed
				mov([eax], eax);
				//Read offset 12 of the item to be removed
				add(12, eax);
				//Dereference the pointer in the object to be removed and store that in edx
				//edx contains the trailing object address
				mov([eax], edx);

				//Dereference the address of the pointer to be updated (containing a pointer to the
				//target object) and pass that to get freed from memory
				mem.free([ebx]);

				mov(edx, [ebx]);
				//write the trailing object address to the location of the pointer to be updated

				mov(itemCount, eax);
				dec(eax);
				mov(eax, itemCount);

			elseif (eax == 0) then
				//First item intended for removal
			else
				//Last item intended for removal

			endif;

			pop(ebp);
			pop(edx);
			pop(ecx);
			pop(ebx);
			pop(eax);
		end list_removeItem;

	procedure list_getItemName(itemPointer:dword);
		//Destroys eax
		begin list_getItemName;
			mov(itemPointer, eax);
			mov([eax], eax);
		end list_getItemName;

	procedure list_getItemPrice(itemPointer:dword);
		//Destroys eax
		begin list_getItemPrice;
			mov(itemPointer, eax);
			mov([eax + 4], eax);
		end list_getItemPrice;

	procedure list_getItemQuantity(itemPointer:dword);
		//Destroys eax
		begin list_getItemQuantity;
			mov(itemPointer, eax);
			mov([eax + 8], eax);
		end list_getItemQuantity;

	procedure list_decrementItemQuantity(itemPointer:dword);
		begin list_decrementItemQuantity;
			push(eax);
			push(ebx);

			//Move the item pointer to eax
			mov(itemPointer, eax);
			//Move the value at offset 8 to ebx
			mov([eax + 8], ebx);
			//Decrement ebx
			dec(ebx);
			//Move ebx back into eax offset 8
			mov(ebx, [eax + 8]);

			pop(ebx);
			pop(eax);
		end list_decrementItemQuantity;

	procedure list_getLastItem;
		//Destroys eax
		begin list_getLastItem;
			//Save old ebx
			push(ebx);

			//Move the first item into both eax and ebx
			mov(firstItem, eax);
			//Ebx stores the newly read pointer, eax stores the current one
			mov(firstItem, ebx);

			//Loop until we get the last item
			forever
				//If the current pointer we just read is null, we break
				//If there are no entries, it should be null, so we break
				//EAX is already set to null, so we just return if there are no
				//entries and the calling function handles it
				breakif(ebx == 0);

				//It's not null, move the just read pointer to eax as this is the
				//valid pointer of the most recent struct
				mov(ebx, eax);

				//Read offset 12 in memory of the known valid pointer into ebx,
				//then going to the next loop iteration until we hit null and stop
				mov([eax + 12], ebx);
			endfor;

			//Restore old ebx from the stack
			pop(ebx);

			//EAX now contains the last entry in the linked list
		end list_getLastItem;

//Input definitions
	procedure input_getNumber(promptText:string);
		//Destroys eax
		begin input_getNumber;
			forever
				try
					//Flush input and get number
					stdin.flushInput();

					//Output the prompt
					
					mov(promptText, eax);
					if (eax != 0) then
						stdout.put(promptText);
					endif;

					stdin.getu32();
					
					unprotected
						break;
				anyexception
					stdout.put("You have entered an invalid number. Please try again.", nl);
				endtry;
			endfor;
		end input_getNumber;

	procedure input_getNumberInRange(promptText:string; min:uns32; max:uns32);
		begin input_getNumberInRange;
			forever
				input_getNumber(promptText);

				if (eax > max || eax < min) then
					stdout.put("You have entered a number out of range. (", min, "-", max, ")", nl);
				else
					break;
				endif;

			endfor;
		end input_getNumberInRange;

//Rendering definitions
	procedure renderClear;
		begin renderClear;
			console.home();
		end renderClear;

	procedure renderLine;
		begin renderLine;
			stdout.put("------------------------------------------------", nl);
		end renderLine;

	procedure renderItem(itemNumber:uns32; itemPointer:dword);
		begin renderItem;
			push(eax);

			mov(itemNumber, eax);
			if (eax > 0) then
				stdout.put((type uns32 eax), ". ");
			endif;

			list_getItemName(itemPointer);
			stdout.put("Name: ", (type string eax), ", ");

			list_getItemPrice(itemPointer);
			stdout.put("Price: ", (type uns32 eax), ", ");

			list_getItemQuantity(itemPointer);
			stdout.put("Quantity: ", (type uns32 eax), " ", nl);

			pop(eax);
		end renderItem;

	procedure renderItems;
		begin renderItems;
			push(eax);
			push(ebx);
			push(ecx);

			//Loop through all items
			for (mov(0, ecx); ecx < itemCount; inc(ecx)) do
				//Get the list item at index of ecx
				list_getItem(ecx);
				renderItem(0, eax);
			endfor;

			pop(ecx);
			pop(ebx);
			pop(eax);
		end renderItems;

//Money definitions

	procedure currency_addCredit(currencyAmount:uns32);
		begin currency_addCredit;
		end currency_addCredit;

	procedure currency_subtractCredit(currencyAmount:uns32);
		begin currency_subtractCredit;
		end currency_subtractCredit;

// --------------------------- Program Entry Point ----------------------------

begin VendingMachine;
	list_createItem("Coke", 199, 100);
	list_createItem("Diet Coke", 189, 100);
	list_createItem("Sprite", 199, 100);
	list_createItem("Dr. Pepper", 199, 100);

	renderItems();

	list_removeItem(1);

	stdout.put(nl, nl);

	renderItems();

end VendingMachine;